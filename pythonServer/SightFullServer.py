# -*- coding: utf-8 -*-
#"""keras-ocr-complet.ipynb

#Automatically generated by Colaboratory.

#Original file is located at
#    https://colab.research.google.com/drive/1R53Bba2YGKWf26t7kpYFUc6fXOGHJ3wq
#"""

#!pip install gtts
#!pip install keras_ocr

from gtts import gTTS
import keras_ocr
import keras_ocr.tools
import socket
import io
import PIL.Image as Image
import struct

def gTTS_call(vocalText):
    ########### GTTS ############
  tts = gTTS(text=vocalText, lang="it")
  tts.save("C:/Users/Alessandro/Desktop/SistemiDigitali/vocal.mp3")



def DL_recognition(buff):
  pipeline = keras_ocr.pipeline.Pipeline()
  #image_for_Keras = keras_ocr.tools.read(path_to_image) 
  images = [keras_ocr.tools.read(buff)]
  prediction_groups = pipeline.recognize(images);
  return prediction_groups;


######WORD SORTING ALGORITHM########

#- lista di appoggio che restituisce la lista ordinata delle parole
#- itero sugli elementi della lista passata come parametro
#- individuo un set di elementi che hanno la y minore --> guardo al primo valore di coordinate nell'array
#- tra quegli elementi scelgo l'elemento con x minore
#- appendo quell'elemento alla lista di appoggio ed elimino quell'elemento dalla lista dei parametri
#- itero il procedimento finchè la lista non è vuota
offset = 20

def isAround(y, record):
  res = record-y
  if res < offset and res > offset:
    return True
  else:
    return False

def findTopLeftValue(lista):
  if len(lista) == 0:
    return None
  recordTopMin = lista[0][1][0][1]
  topList = []
  for element in lista:
    y=element[1][0][1]
    if y < recordTopMin:
      recordTopMin = y
    if isAround(y,recordTopMin):
      topList.append(element)
  recordLeft = topList[0]
  for topElement in topList:
    x=topElement[1][0][0]
    if x<recordLeft[1][0][0]: 
      recordLeft = topElement
  for element in lista:
    if element == recordLeft:
      lista.remove(element)
      break
  return recordLeft

def sortElements(lista):
  sortedList = []
  element = lista[0]
  while element!=None:
    if len(lista) == 0:
      break
    element = findTopLeftValue(lista)
    sortedList.append(element)
  return sortedList



def recv_msg(sock):
    # Read message length and unpack it into an integer
    raw_msglen = recvall(sock, 4)
    if not raw_msglen:
        return None
    msglen = struct.unpack('>I', raw_msglen)[0]
    # Read the message data
    return recvall(sock, msglen)
    
def recvall(sock, n):
    # Helper function to recv n bytes or return None if EOF is hit
    data = bytearray()
    while len(data) < n:
      packet = sock.recv(n - len(data))
      if not packet:
        return None
      data.extend(packet)
    return data

savepath="C:/Users/Alessandro/Desktop/SistemiDigitali/img.jpeg" #change when needed

def main():
  HOST = "192.168.1.237"  #My eth0 address -> CHANGE IF SERVER MACHINE IS CHANGED
  #HOST = "localhost"
  PORT = 65432  # Port to listen on (non-privileged ports are > 1023)

  s=socket.socket(socket.AF_INET, socket.SOCK_STREAM)
  s.bind((HOST, PORT))
  s.listen()
  print(f"server is running on {HOST}........")
  while True:
    conn, addr = s.accept()
    with conn:
       print(f"Connected by {addr}")
       data = recv_msg(conn)
       print('Data received')
       if not data:
        break
       image = Image.open(io.BytesIO(data))
       image.save(savepath)
       prediction_groups=DL_recognition(io.BytesIO(data))
       pg = prediction_groups[0].copy()
       sortedElements = sortElements(pg)
       vocalText =""
       for text in sortedElements[:]:
          vocalText += text[0] +" "
       vocalText += "\n"
       bytes_to_send=vocalText.encode()
       conn.sendall(bytes_to_send)
       conn.close()
       print(f"Operation complete...{vocalText}")
       #gTTS_call(vocalText)
            
              
   


if __name__ == "__main__":
    main()
